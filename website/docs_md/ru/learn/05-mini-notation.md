# Mini Notation

# Mini-notation

Так же как и [Tidal Cycles](https://tidalcycles.org/), Strudel использует так называемый "Mini-Notation", который представляет собой специальный язык, предназначенный для записи ритмических patterns с использованием небольшого количества текста.

## Примечание

Эта страница объясняет весь синтаксис Mini-Notation целиком.
Если вы только начинаете работать со Strudel, вы можете изучить основы Mini-Notation более практичным способом в [workshop](/workshop/first-sounds).
После этого вы можете вернуться сюда, если хотите понять каждую мелочь.

## Пример

Прежде чем углубляться в детали, вот как выглядит Mini-Notation:

<MiniRepl
  client:idle
  tune={`note(\`<
[e5 [b4 c5] d5 [c5 b4]]
[a4 [a4 c5] e5 [d5 c5]]
[b4 [~ c5] d5 e5]
[c5 a4 a4 ~]
[[~ d5] [~ f5] a5 [g5 f5]]
[e5 [~ c5] e5 [d5 c5]]
[b4 [b4 c5] d5 e5]
[c5 a4 a4 ~]
,
[[e2 e3]*4]
[[a2 a3]*4]
[[g#2 g#3]*2 [e2 e3]*2]
[a2 a3 a2 a3 a2 a3 b1 c2]
[[d2 d3]*4]
[[c2 c3]*4]
[[b1 b2]*2 [e2 e3]*2]
[[a1 a2]*4]
>\`)`}
/>

## Формат Mini Notation

Приведенный выше фрагмент заключен в обратные кавычки (`), что позволяет писать многострочные строки.

Вы также можете использовать обычные двойные кавычки (`"`) для однострочного mini-notation, как мы уже делали.

Если вы хотите получить обычную строку, которая _не_ парсится как mini-notation, используйте одинарные кавычки (`'`).

## Последовательности events в cycle

Мы можем воспроизвести больше нот, разделив их пробелами:

```javascript
// Пример:
note("c e g b")
```

Здесь эти четыре ноты сжаты в один cycle, поэтому каждая нота длится четверть секунды.
Попробуйте добавить или удалить ноты и обратите внимание, как меняется темп!

```javascript
// Пример:
note("c d e f g a b")
```

Обратите внимание, что общая продолжительность времени не меняется, вместо этого уменьшается длительность каждой ноты.
Это ключевая идея, так как она иллюстрирует 'Cycle' в TidalCycles!

Каждая нота, разделенная пробелом в этой последовательности, является _event_.
Продолжительность времени каждого event зависит от скорости или темпа cycle и от того, сколько events присутствует.
Возьмем два приведенных выше примера: у нас четыре и восемь events соответственно, и поскольку у них одинаковая длительность cycle, каждому нужно вместить свои events в одно и то же количество времени.

Это, возможно, противоречит интуиции, если вы привыкли добавлять ноты в секвенсор или piano roll, и общая длина увеличивается.
Но это начнет иметь смысл, когда мы рассмотрим больше элементов mini-notation.

## Умножение

Последовательность можно ускорить, умножив ее на число с помощью символа звездочки (`*`):

```javascript
// Пример:
note("[e5 b4 d5 c5]*2")
```

Умножение на два здесь означает, что последовательность будет воспроизводиться дважды за cycle.

Умножения также могут быть десятичными (`*2.75`):

```javascript
// Пример:
note("[e5 b4 d5 c5]*2.75")
```

## Деление

В противоположность умножению, деление может замедлить последовательность, заключив ее в скобки и разделив на число (`/2`):

```javascript
// Пример:
note("[e5 b4 d5 c5]/2")
```

Деление на два означает, что последовательность будет воспроизводиться в течение двух cycles.
Вы также можете использовать десятичные числа для любого темпа, который вам нравится (`/2.75`).

```javascript
// Пример:
note("[e5 b4 d5 c5]/2.75")
```

## Угловые скобки

Используя угловые скобки `<>`, мы можем определить длину последовательности на основе количества events:

<MiniRepl client:idle tune={`note("<e5 b4 d5 c5>")`} punchcard />

Приведенный выше фрагмент аналогичен:

```javascript
// Пример:
note("[e5 b4 d5 c5]/4")
```

Преимущество угловых скобок в том, что мы можем добавлять больше events без необходимости изменять число в конце.

<MiniRepl client:idle tune={`note("<e5 b4 d5 c5 e5>")`} punchcard />

<MiniRepl client:idle tune={`note("<e5 b4 d5 c5 e5 b4>")`} punchcard />

Это более похоже на традиционные музыкальные секвенсоры и piano rolls, где добавление ноты увеличивает воспринимаемую общую продолжительность.
Мы также можем воспроизводить определенное количество нот за cycle, используя угловые скобки с умножением:

<MiniRepl client:idle tune={`note("<e5 b4 d5 c5 a4 c5>*8")`} punchcard />

Теперь мы воспроизводим 8 нот за cycle!

## Подразделение времени с вложенными скобками

Чтобы создать более интересные ритмы, вы можете _вложить_ или _заключить_ последовательности (поместить последовательности внутрь последовательностей) с помощью скобок `[]`, вот так:

Сравните разницу между следующими:

```javascript
// Пример:
note("e5 b4 c5 d5 c5 b4")
```

```javascript
// Пример:
note("e5 [b4 c5] d5 c5 b4")
```

```javascript
// Пример:
note("e5 [b4 c5] d5 [c5 b4]")
```

```javascript
// Пример:
note("e5 [b4 c5] d5 [c5 b4 d5 e5]")
```

```javascript
// Пример:
note("e5 [b4 c5] d5 [c5 b4 [d5 e5]]")
```

Что здесь происходит? Когда мы вкладываем/заключаем несколько events внутри скобок (`[]`), их длительность становится равной длине одного event во внешней последовательности.

Это очень простое изменение, но оно имеет глубокие последствия.
Помните, что мы говорили ранее о том, как cycles в tidal остаются одинаковой длины, а длительности отдельных events делятся в этом cycle?
Что ж, это означает, что в TidalCycles вы не только можете делить время любым способом, но и можете подразделять время любым способом!

## Паузы

Символ "~" представляет паузу и создаст тишину между другими events:

```javascript
// Пример:
note("[b4 [~ c5] d5 e5]")
```

## Параллельность / полифония

Используя запятые, мы можем воспроизводить аккорды.
Следующие примеры одинаковы:

```javascript
// Пример:
note("[g3,b3,e4]")
```

```javascript
// Пример:
note("g3,b3,e4")
```

Но чтобы воспроизвести несколько аккордов в последовательности, нужно обернуть их в скобки:

<MiniRepl client:idle tune={`note("<[g3,b3,e4] [a3,c3,e4] [b3,d3,f#4] [b3,e4,g4]>*2")`} punchcard />

## Удлинение

С помощью символа "@" мы можем указать временной "вес" дочернего элемента последовательности:

<MiniRepl client:idle tune={`note("<[g3,b3,e4]@2 [a3,c3,e4] [b3,d3,f#4]>*2")`} punchcard />

Здесь первый аккорд имеет вес 2, что делает его в два раза длиннее других аккордов. Вес по умолчанию — 1.

## Повторение

Используя "!" мы можем повторять без ускорения:

<MiniRepl client:idle tune={`note("<[g3,b3,e4]!2 [a3,c3,e4] [b3,d3,f#4]>*2")`} punchcard />

## Случайность

Events с "?" после них будут иметь 50% шанс быть удаленными из pattern:

```javascript
// Пример:
note("[g3,b3,e4]*8?")
```

Добавление числа между 0 и 1 после "?" повлияет на вероятность удаления event. Например, events с "?0.1" после них будут иметь 10% шанс быть удаленными:

```javascript
// Пример:
note("[g3,b3,e4]*8?0.1")
```

Events, разделенные "|", будут выбраны случайным образом:

```javascript
// Пример:
note("[g3,b3,e4] | [a3,c3,e4] | [b3,d3,f#4]")
```

## Обзор mini-notation

Чтобы подытожить то, что мы узнали до сих пор, сравните следующие patterns:

<MiniRepl client:idle tune={`note("<g3 b3 e4 [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4] [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4]/2 [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4]*2 [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4] _ [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4]@2 [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4]!2 [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3,b3,e4]? [a3,c3,e4] [b3,d3,f#4]>*2")`} />
<MiniRepl client:idle tune={`note("<[g3|b3|e4] [a3,c3,e4] [b3,d3,f#4]>*2")`} />

## Euclidian rhythms

Используя круглые скобки после event, мы можем создавать ритмические подразделения на основе трех параметров: `beats`, `segments` и `offset`.
Этот алгоритм можно найти во многих различных типах музыкального программного обеспечения, и он часто называется секвенсором [Euclidean rhythm](https://en.wikipedia.org/wiki/Euclidean_rhythm), в честь компьютерного ученого Годфрида Туссена.
Почему это интересно? Рассмотрим следующий простой пример:

```javascript
// Пример:
s("bd(3,8,0)")
```

Звучит знакомо?
Это популярный Euclidian rhythm, известный под различными названиями, такими как "Pop Clave".
Эти ритмы можно найти во всех музыкальных культурах, и алгоритм Euclidian rhythm позволяет нам выразить их чрезвычайно легко.
Написание этого ритма полностью требует описания:

```javascript
// Пример:
s("bd ~ ~ bd ~ ~ bd ~")
```

Но используя нотацию Euclidian rhythm, нам нужно выразить только "3 удара на 8 сегментов, начиная с позиции 1".

Это упрощает написание patterns с интересными ритмическими структурами и вариациями, которые все еще звучат знакомо:

```javascript
// Пример:
note("e5(2,8) b4(3,8) d5(2,8) c5(3,8)").slow(2)
```

Обратите внимание, что поскольку в приведенном выше примере не используется третий параметр `offset`, его можно записать просто как `"(3,8)"`.

```javascript
// Пример:
s("bd(3,8)")
```

Давайте подробно рассмотрим эти три параметра.

### Beats

`beats`: первый параметр контролирует, сколько ударов будет воспроизведено.
Сравните эти:

```javascript
// Пример:
s("bd(2,8)")
```

```javascript
// Пример:
s("bd(5,8)")
```

```javascript
// Пример:
s("bd(7,8)")
```

### Segments

`segments`: второй параметр контролирует общее количество сегментов, по которым будут распределены удары:

```javascript
// Пример:
s("bd(3,4)")
```

```javascript
// Пример:
s("bd(3,8)")
```

```javascript
// Пример:
s("bd(3,13)")
```

### Offsets

`offset`: третий (необязательный) параметр контролирует начальную позицию для распределения ударов.
Нам нужен вторичный ритм, чтобы услышать разницу:

```javascript
// Пример:
s("bd(3,8,0), hh cp")
```

```javascript
// Пример:
s("bd(3,8,3), hh cp")
```

```javascript
// Пример:
s("bd(3,8,5), hh cp")
```

## Упражнение по mini-notation

Самое интересное в mini-notation — это то, что все, что вы только что изучили, можно комбинировать различными способами!

Начиная с этого одного `n`, можете ли вы создать _строку pattern_, которая использует каждый отдельный элемент mini-notation, упомянутый выше?

```javascript
// Пример:
n("60")
```

<br />

Далее: Как [Samples](/learn/samples) вписываются в это?

