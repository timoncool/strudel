---
title: Patterns
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Patterns

Patterns являются сущностью Tidal. Его patterns - это абстрактные сущности, представляющие потоки времени в виде функций, адаптируя технику, называемую чистым функциональным реактивным программированием. Принимая временной диапазон в качестве входных данных, Pattern может выдавать набор событий, которые происходят в течение этого временного диапазона. От структуры Pattern зависит, как события расположены во времени.
С этого момента этот процесс генерации событий из временного диапазона будет называться **запросом** (querying).
Пример:

<MiniRepl
  client:idle
  tune={`const pattern = sequence("c3", ["e3", "g3"])
const events = pattern.queryArc(0, 1)
console.log(events.map((e) => e.show()))
silence`}
/>

В этом примере мы создаем pattern с помощью функции `sequence` и **запрашиваем** его для временного диапазона от `0` до `1`.
Эти числа представляют единицы времени, называемые **cycles**. Длина одного cycle зависит от темпа, который по умолчанию равен одному cycle в секунду.
Полученные события:

```js
[
  '[ 0/1 -> 1/2 | c3 ]', //
  '[ 1/2 -> 3/4 | e3 ]',
  '[ 3/4 -> 1/1 | g3 ]',
];
```

Каждое событие имеет значение, время начала и время окончания, где время представлено в виде дроби. В приведенном выше случае события размещены в последовательном порядке, где c3 занимает первую половину, а e3 и g3 вместе занимают вторую половину. Это временное размещение является результатом функции `sequence`, которая делит свои аргументы поровну на один cycle. Если аргумент является массивом, то же правило применяется к этой части cycle. В примере e3 и g3 делятся поровну на вторую половину всего cycle.

Обратите внимание, что функция query - это не просто способ доступа к pattern, а в соответствии с принципами функционального программирования, является самим pattern. Это означает, что теоретически нет способа изменить pattern, он непрозрачен как чистая функция. На практике же Strudel и Tidal - это все о трансформации patterns, так как же это делается? Ответ - заменой pattern новым, который вызывает старый. Этот новый способен только манипулировать запросом перед передачей его старому pattern и манипулировать результатами от него перед их возвратом вызывающей стороне. Но этого достаточно для поддержки всех временных и структурных манипуляций, предоставляемых обширной библиотекой функций Strudel (и Tidal).

Приведенные выше примеры не представляют, как Strudel используется на практике. В редакторе live coding пользователю нужно только ввести сам pattern, запрос будет обработан планировщиком (scheduler). Планировщик будет многократно запрашивать pattern для событий, которые затем планируются как синтез звука или другие триггеры событий.

Можем ли мы [выравнивать](/technical-manual/alignment) patterns?
