---
title: Synths
layout: ../../layouts/MainLayout.astro
---

import { MiniRepl } from '../../docs/MiniRepl';
import { JsDoc } from '../../docs/JsDoc';

# Synths

В дополнение к движку сэмплирования, strudel поставляется с синтезатором для создания звуков на лету.

## Базовые Waveforms

Базовые waveforms — это `sine`, `sawtooth`, `square` и `triangle`, которые можно выбрать через `sound` (или `s`):

<MiniRepl
  client:idle
  tune={`note("c2 <eb2 <g2 g1>>".fast(2))
.sound("<sawtooth square triangle sine>")
._scope()`}
/>

Если вы не установите `sound`, но установите `note`, значением по умолчанию для `sound` будет `triangle`!

## Noise

Вы также можете использовать noise в качестве источника, установив waveform на: `white`, `pink` или `brown`. Это разные
виды noise, здесь написаны от жесткого к мягкому.

<MiniRepl client:idle tune={`sound("<white pink brown>")._scope()`} />

Вот более музыкальный пример использования noise для хэтов:

<MiniRepl
  client:idle
  tune={`sound("bd*2,<white pink brown>*8")
.decay(.04).sustain(0)._scope()`}
/>

Некоторое количество pink noise также может быть добавлено к любому oscillator с помощью параметра `noise`:

<MiniRepl client:idle tune={`note("c3").noise("<0.1 0.25 0.5>")._scope()`} />

Вы также можете использовать тип `crackle` для воспроизведения тонких шумовых треска. Вы можете контролировать количество noise, используя параметр `density`:

<MiniRepl client:idle tune={`s("crackle*4").density("<0.01 0.04 0.2 0.5>".slow(2))._scope()`} />

### Additive Synthesis

Периодические waveforms состоят из нескольких [harmonics](https://en.wikipedia.org/wiki/Harmonic) выше основной частоты, расположенных на целых кратных. Эти обертоны объединяются, чтобы придать звуку его уникальное тембральное качество.

Для базовых waveforms мы предлагаем вам контроль над этими harmonics с помощью функций `partials` и `phases`.

#### Partials

`partials` относится к величине каждого harmonic относительно основной частоты. Таким образом, их можно использовать для спектральной фильтрации этих waveforms и смягчения некоторой их резкости:

<MiniRepl
  client:idle
  tune={`note("c2 <eb2 <g2 g1>>".fast(2))
.sound("sawtooth")
.partials([1, 1, "<1 0>", "<1 0>", "<1 0>", "<1 0>", "<1 0>"])
._scope()`}
/>

`partials` также можно использовать для построения _новых_ waveforms, отсутствующих в нашем базовом наборе, с помощью источника звука 'user':

<MiniRepl
  client:idle
  tune={`note("c2 <eb2 <g2 g1>>".fast(2))
.sound("user")
.partials([1, 0, 0.3, 0, 0.1, 0, 0, 0.3])
._scope()`}
/>

Мы можем алгоритмически создавать списки величин с помощью кода Javascript следующим образом:

<MiniRepl
  client:idle
  tune={`const numHarmonics = 22;
note("c2 <eb2 <g2 g1>>".fast(2))
.sound("saw")
.partials(new Array(numHarmonics).fill(1))
._scope()`}
/>

что действует как спектральный filter. Или:

<MiniRepl
  client:idle
  tune={`note("c2 <eb2 <g2 g1>>").fast(2)
.sound("user")
.partials(new Array(50).fill(0)
  .map((_, idx) => ((-1) ** (idx + 1)) / (idx + 1))
)
._scope()`}
/>

что восстанавливает знакомую waveform.

`partials` также совместим с функциями pattern, предназначенными для создания списков, такими как `randL` или `binaryL`:

<MiniRepl
  client:idle
  tune={`note("c2 <eb2 <g2 g1>>").fast(2)
.sound("user")
.partials(randL(10))
._scope()`}
/>

и со списками _из_ patterns:

<MiniRepl
  client:idle
  tune={`note("c2 <eb2 <g2 g1>>".fast(4))
.sound("user")
.partials([1, 0, "0 1", "0 1 0.3", rand])
._scope()`}
/>

Обратите внимание, что первое значение в массиве `partials` контролирует величину фундаментального harmonic, а не смещение по постоянному току, которое зафиксировано на 0.

#### Phases

Ранее мы упоминали, что периодические waveforms можно разложить на набор harmonics выше основной частоты. Каждый harmonic имеет два определяющих свойства: его величину (насколько он громкий) и его фазу, которая определяет, где в своем цикле начинается эта синусоида при построении waveform.

Эти phases также могут быть объявлены в Strudel и могут придать вашим звукам интересную глубину.

<MiniRepl
  client:idle
  tune={`s("saw").seg(16).n(irand(12)).scale("F1:minor")
  .penv(48).panchor(0).pdec(0.05)
  .delay(0.25).room(0.25)
  .compressor(-20).vib(0.3)
  .partials(randL(200))
  .phases(randL(200))`}
/>

## Vibrato

### vib

<JsDoc client:idle name="vib" h={0} />

### vibmod

<JsDoc client:idle name="vibmod" h={0} />

## FM Synthesis

FM Synthesis — это техника, которая быстро изменяет частоту базовой waveform для изменения тембра.

Вы можете использовать fm с любой из вышеперечисленных waveforms, хотя все приведенные ниже примеры используют triangle wave по умолчанию.

### fm

<JsDoc client:idle name="fm" h={0} />

### fmh

<JsDoc client:idle name="fmh" h={0} />

### fmattack

<JsDoc client:idle name="fmattack" h={0} />

### fmdecay

<JsDoc client:idle name="fmdecay" h={0} />

### fmsustain

<JsDoc client:idle name="fmsustain" h={0} />

### fmenv

<JsDoc client:idle name="fmenv" h={0} />

## Wavetable Synthesis

Strudel также может использовать sampler для загрузки пользовательских waveforms в качестве замены waveforms по умолчанию, используемых WebAudio для базового synth. Набор по умолчанию из более чем 1000 wavetables доступен по умолчанию (из набора [AKWF](https://www.adventurekid.se/akrt/waveforms/adventure-kid-waveforms/)). Вы также можете импортировать/использовать свои собственные. Wavetable — это waveform одного цикла, которая затем повторяется для создания звука на желаемой частоте. Это классическая, но очень эффективная техника синтеза.

Любой sample с префиксом `wt_` будет загружен как wavetable. Это означает, что аргумент `loop` будет установлен на `1` по умолчанию. Вы также можете сканировать wavetable, используя `loopBegin` и `loopEnd`.

<MiniRepl
  client:idle
  tune={`samples('bubo:waveforms');
note("<[g3,b3,e4]!2 [a3,c3,e4] [b3,d3,f#4]>")
.n("<1 2 3 4 5 6 7 8 9 10>/2").room(0.5).size(0.9)
.s('wt_flute').velocity(0.25).often(n => n.ply(2))
.release(0.125).decay("<0.1 0.25 0.3 0.4>").sustain(0)
.cutoff(2000).cutoff("<1000 2000 4000>").fast(4)
._scope()
`}
/>

## ZZFX

"Zuper Zmall Zound Zynth" [ZZFX](https://github.com/KilledByAPixel/ZzFX) также интегрирован в strudel.
Разработанный [Frank Force](https://frankforce.com/), это движок synth и FX, изначально предназначенный для использования в играх с ограниченным размером кода.

У него всего 20 параметров, вот фрагмент, который использует все:

<MiniRepl
  client:idle
  tune={`note("c2 eb2 f2 g2") // также поддерживает freq
  .s("{z_sawtooth z_tan z_noise z_sine z_square}%4")
  .zrand(0) // randomization
  // zzfx envelope
  .attack(0.001)
  .decay(0.1)
  .sustain(.8)
  .release(.1)
  // специальные параметры zzfx
  .curve(1) // waveshape 1-3
  .slide(0) // +/- скольжение высоты тона
  .deltaSlide(0) // +/- скольжение высоты тона (?)
  .noise(0) // сделать грязнее
  .zmod(0) // скорость fm
  .zcrush(0) // bit crush 0 - 1
  .zdelay(0) // простой delay
  .pitchJump(0) // +/- изменение высоты тона после pitchJumpTime
  .pitchJumpTime(0) // >0 время после применения pitchJump
  .lfo(0) // >0 сбрасывает slide + pitchJump + устанавливает скорость tremolo
  .tremolo(0.5) // 0-1 количество модуляции громкости lfo
  //.duration(.2) // переопределить длительность event strudel
  //.gain(1) // изменить громкость
  ._scope() // визуализация waveform (не связана с zzfx)
`}
/>

Обратите внимание, что вы также можете комбинировать zzfx со всеми другими audio fx (следующая глава).

Далее: [Audio Effects](/learn/effects)...
